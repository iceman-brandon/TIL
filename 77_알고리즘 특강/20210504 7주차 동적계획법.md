**알고리즘 특강 7주차**

**동적계획법**

- 동적계획법이란
  - 다이나믹 프로그래밍(Dynamic Programming, DP)라고도 불리며,
    하나의 큰 문제를 여러개의 공통되는 작은 문제로 나누어서
    작은 문제의 정답들을 결합하여 알고리즘을 푸는 과정
- 점화식
  - 수열에서 n번째 항을 이전에 나온 항들로 나타낸 공식

![image](https://user-images.githubusercontent.com/78403443/116979662-3d996380-ad00-11eb-8f45-6419d72b8983.png)

문제에 따라서 규칙은 n이라고 하는 하나의 변수에 관한 규칙일 수도 있다.

![image](https://user-images.githubusercontent.com/78403443/116979796-64579a00-ad00-11eb-8b75-2af72e6b9475.png)

아니면, n과 m 두 개의 관한 변수일 수도 있고, 혹은 그 이상일 수도 있다.

![image](https://user-images.githubusercontent.com/78403443/116979901-881ae000-ad00-11eb-8acf-317d78b90dd0.png)

결국 규칙은 스스로가 찾아낼 수 있다면 코드로 구현하는 것은 어려운 일이 아닐 것이다.

많은 온라인 자료들은 동적계획법을 어떻게 풀어낼 수 있을까에 대해 크게 2가지 방법을 얘기하고 있다.



- 동적계획법 접근방법

![image](https://user-images.githubusercontent.com/78403443/116980036-b4cef780-ad00-11eb-8254-a2a914a5f9f4.png)

Bottom Up 방법은 규칙에 따라 정답을 찾아나가는데 있어서 반복문을 활용한 방법

Top Down은 재귀함수를 호출하여 재귀함수 아래까지 조사하는 방법



- 피보나치 수열을 Bottom Up 방식으로 접근한다.

  - 먼저, 배열 선언

  ![image](https://user-images.githubusercontent.com/78403443/116980362-18f1bb80-ad01-11eb-95d9-7259f649e354.png)

이런식으로 반복문이 활용되다가

우리가 원하는 n에 도착하였을 때 그 값을 리턴해주는 방식이 

바로 동적계획법의 Bottom Up 방식이다.



- 코드로 보자
  - 피보나치 수열의 함수를 선언한다.
  - 값을 저장할 배열에 1과 1을 미리 담는다.
  - 반복문을 활용해서 이전 항들의 합을 계속해서 저장해나가도록 한다.
  - 반복문이 끝나고 난 다음에 배열의 가장 마지막에 들어간 값을 반환해주도록 한다.

![image](https://user-images.githubusercontent.com/78403443/116980703-8271ca00-ad01-11eb-912d-9490f63e7d23.png)





- 동적계획법의 Top Down 방식을 활용하여 피보나치 수열을 풀어보도록 한다.
  - Top Down은 정답을 쪼개 작은 정답들의 결합으로 정답을 구하는 방법이다.
  - 재귀함수를 활용하면 쉽게 구현할 수 있다.
  - 먼저, 우리가 구하고자 하는 값 피보나치 수열의 n번째 값을 선언한다.
  - n번째 값을 구하기 위해서 바로 이전 두개의 피보나치 수열의 값이 필요하다.
  - 이 값들을 구하기 위해서 다시 이전 두개의 값들이 필요하다. 
  - 이 과정이 반복되다보면 피보나치 수열의 첫번째 항과 두번째 항의 값을 필요로 하게 될 것이다.
  - 하지만, 첫번째 항과 두번째 항 즉 n이 0일 때와 1일 때인 경우에는 그 값들이 더이상 쪼개지지 않고 1을 반환하게 된다.
  - 결국, 피보나치 수열의 n번째 항은 0번째 수열과 1번째 수열의 결합으로 이루어지는 것이다.

![image](https://user-images.githubusercontent.com/78403443/116981290-425f1700-ad02-11eb-8305-93f9d0a1995c.png)



- 코드로 보자

  - n이 0과 1인 경우에는 1을 반환해주도록 한다.
  - 그렇지 않다면은 바로 이전 두개 항의 합으로써 반환을 하면 되겠다.

  ![image](https://user-images.githubusercontent.com/78403443/116981464-7a665a00-ad02-11eb-858c-29c80a629946.png)

이렇게 우리는 동적계획법의 Top Down 방법에 대해서 알아보았다. 

하지만, 여기에는 문제가 있다. 

바로, 피보나치 수열 값 하나를 계산하기 위해서는 많은 양의 계산이 필요로 하게되고 그와 동시에 중복된 계산이 발생하게 된다.

![image](https://user-images.githubusercontent.com/78403443/116981621-bd283200-ad02-11eb-95d1-81242138962a.png)

이와 같은 문제를 해결하기 위해 우리는 메모이제이션이라는 기술이 필요하다.

메모이제이션이란 앞에서 했던 계산을 어딘가에 저장해두고 필요한 경우 불러와서 활용할 수 있도록 하여 중복된 계산이 발생하는 것을 방지하는 방법.

한번 코드로 보자.

1. 먼저, 메모이제이션을 활용할 딕셔너리를 선언하도록 한다. (배열을 사용해도 좋다)
2. 그리고, 피보나치 수를 구하기 전에 앞서서 딕셔너리에 값이 저장이 되어있다면 저장된 값을 불러오도록 하고,
   그렇지 않다면 재귀함수를 활용하여 값을 찾는다. 그리고 찾은 값을 딕셔너리 혹은 배열에 다시 저장하고 그 값을 반환한다.

![image](https://user-images.githubusercontent.com/78403443/116982092-58210c00-ad03-11eb-8053-b5b8874959b0.png)

**즉, 메모이제이션(Memoization)은 배열 혹은 해시를 활용하는 것이 핵심이다!**



동적계획법을 활용한 조금 더 어려운 예시...

- 동적계획법 예시

  - 여기 7개의 성분을 가진 배열이 하나 있다.
  - 이 배열들의 성분으로 이웃하지 않는 숫자들끼리 만들 수 있는 합 중에 최대값을 구하고자 한다.
  - 어떻게 할 수 있을까?
  - 과연 어떻게 해야 적절한 숫자를 선택해서 합을 최대가 되게 할 수 있을까?
  - 가능한 모든 경우의 수를 조사하는 완전탐색이지만 이 문제에 대한 규칙을 한번 같이 살펴보도록 하자.

  ![image](https://user-images.githubusercontent.com/78403443/116984063-cb2b8200-ad05-11eb-8a90-f7ae9868c8d0.png)

  - 먼저, 메모이제이션을 위한 배열을 하나 선언해두도록 한다.
  - 그리고, 동적계획법의 정의 그대로 작은 문제들부터 하나하나 쌓아나가도록 한다.
  - 만약 데이터라는 배열이 보는 것처럼 7개의 성분을 가지고 있지 않고 인덱스 0에 위치한 3 하나만 가지고 있다고 생각해보자. 그럼 합의 최대값은 당연히 3이 될 것이다. 
  - 그 3을 배열에 추가해두도록 한다.
  - 그리고, 배열이 3 만을 가지고 있다가 인덱스 1에 위치한 두번째 성분 4가 추가되었다고 생각해보자.
  - 그럼 그때 합의 최대값은 바로 이전 값인 3과 현재의 값인 4 둘 중에 최대값의 합이 최대값이 될 수 있다.
  - 결국 더 큰 4가 살아남게 되는 것이다.
  - 이어서, 배열의 인덱스 2에 위치한 세번째 성분 5가 추가되었다고 생각해보자.
  - 그럼 그때 최대값은 바로 이전 값인 4와, 현재 값인 5와 그 5와 이웃하지 않은 n=0에서의 3 과의 합 중 더 큰 값이 최대값이 될 수 있다.
  - 결국 8이 최대값이 될 것이다. 
  - 이어서, 같은 방법으로 6이 추가되었다. 
  - 그러면 이전 값인 8과, 현재 값인 6과 그 6과 이웃하지 않은 4와의 합 중 더 큰 값이 최대값이 될 수 있다.
  - 따라서, 더 큰 10이 살아남게 될 것이다.
  - 이어서, 1이 추가 되었다. 
  - 마찬가지로 이전 값인 10과 그리고, 현재 값인 1과 그 전전 값인 8의 합 중에 최대값이 합의 최대값이 될 수 있다. 
  - 하지만, 현재값이 더해진다 하더라도 여전히 이전 값보다 작으므로 이전 값에 위치한 10이 현재의 최대값 그대로 위치할 것이다. 
  - 이어서, 2가 추가되었다. 
  - 현재까지의 합의 최대값은 이전 값과 현재 값과 이웃하지 않은 전전 값인 10과의 합 중 최대값이 되어 현재값의 최대값은 12가 될 것이다.
  - 마지막으로, 5가 추가되었다.
  - 이전 값과 5와 이웃하지 않은 전전값의 합인 10+5 중 최대값인 15가 바로 현재값까지의 최대값으로 우리는 이웃하지 않은 숫자들의 합의 최대값은 15가 됨을 확인할 수 있겠다.

  ![image](https://user-images.githubusercontent.com/78403443/116985797-edbe9a80-ad07-11eb-8d7d-76b23105c24c.png)





규칙을 다시 한번 정리해보도록 하겠다.

현재값 a0(제로)가 있다. 이것은 비교할 값이 없으므로 현재값 자체가 최대값이다. 이 값을 S0(제로)라고 이름을 붙이겠다.

두번째 값은 바로 이전 값 S0(제로)와 아무것도 없는 상태 

즉, 현재 값 0에 a1을 추가한 값 중 최대값이 위치하게 될 것이다. 이 값을 s1 이라고 한다.

세번째 값은 바로 이전값 s1과, 현재 값인 a2와 a2와 인접하지 않은 최대값 s0 와의 합(s0 + a2) 중에 최대값이 될 것이다. 이 값을 s2라고 하겠다.

네번째 값은 바로 이전 값 s2와, 현재 값인 a3와 a3와 인접하지 않은 최대값 s1 과의 합(s1+a3) 중 최대값이 될 것이다. 아 값을 s3 라고 하겠다.

다섯번째 값은 바로 이전 값 s3와, 현재 값인 a4와 a4와 인접하지 않은 최대값 s2 와의 합(s2+a4) 중 최대값이 될 것이다. 이 값을 s4라고 하겠다.

여섯번째 값은 바로 이전 값 s4와, 현재 값인 a5와 a5와 인접하지 않은 최대값 s3 와의 합(s3+a5) 중에 최대 값이 될 것이다. 이 값을 s5라고 하겠다.

마지막 값은 바로 이전 값 s5와, 현재 값인 a6와 a6와 인접하지 않은 최대값 s4 와의 합(s4+a6) 중에 최대 값이 될 것이다. 이 값을 s6라고 하겠다.

그렇게 마지막에 도달하였을 때, s6가 우리가 원하던 이웃하지 않은 숫자들의 합 중 최대값이 되는 것이다.

![image](https://user-images.githubusercontent.com/78403443/116987233-c36ddc80-ad09-11eb-8b43-92e2adbd378f.png)

그럼 이 문제의 규칙이 지금 무엇일까? 라고 질문을 한다면

다음과 같은 식을 찾아냈다고 우리는 말할 수 있다.

![image](https://user-images.githubusercontent.com/78403443/116987311-db456080-ad09-11eb-81cf-7deb1bedb40f.png)

앞에서 규칙에 대한 설명을 충분히 이해했다면 위에 보이는 식을 활용해서 알고리즘을 구현할 수 있을 것이다.



1. 만약 입력된 배열의 길이가 1이라고 한다면, 걱정할 것없이 최대값은 첫번째 원소가 될 것이다.
2. 그렇지 않다면, 메모이제이션을 위한 배열을 선언해두도록 하겠다. (첫번째 성분은 첫번째 값을, 두번째 성분은 첫번째와 두번째의 최대값으로 값을 지정해두도록 하겠다)
3. 그리고, 반복문을 활용해서 Bottom Up 방식을 적용하여 앞에서 찾은 규칙으로 
4. 배열의 아래에서부터 원하는 정답으로 근접해 올라가면서 배열에 계속 담도록 하겠다.
5. 그리고, 정답을 반환해주면 되겠다.

![image](https://user-images.githubusercontent.com/78403443/116988178-fd8bae00-ad0a-11eb-852e-c6157d00c8ce.png)

