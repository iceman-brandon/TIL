**알고리즘 특강 10주차**

**연결리스트와 트라이구조**

<br/>

- **연결리스트(LinkedList)란?**

  - 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 데이터를 저장하는 자료 구조

  <br/>

  리스트는 인덱스를 활용하여 값을 저장하는 반면

  연결리스트는 앞에 있는 값이 바로 뒤에 이어오는 성분을 기억 또는 연결하는 구조로 되어있다.

  <br/>

- **왜 연결리스트라는 개념이 필요할까?**

**리스트**

List는 데이터를 인덱스 값에 따라 저장 

(데이터의 각 인덱스 값 기억, 바로 몇번 인덱스에 몇번 값이 있는지 찾을 수 있는 구조로 되어있다)

그러나 문제가 발생한다. 

![image](https://user-images.githubusercontent.com/78403443/119490154-7aa0c500-bd97-11eb-846b-dc971c099f77.png)

만약 그림처럼 C와 E 사이에 D라고 하는 성분을 삽입한다고 가정

바로 E, F, G에 있는 인덱스값들이 한 칸씩 뒤로 밀려나게 되어 결국 삽입하는 위치서부터 뒤에 있는 모든 데이터의 인덱스를 바꾸는데 많은 시간이 필요할 것이다.

반대로 리스트의 중간에서 삭제하게된다고 하면 뒤에 있는 인덱스 성분을 다시 재조정해야하며 많은 시간이 걸려 다음과 같은 결과를 얻게된다.

![image](https://user-images.githubusercontent.com/78403443/119490270-9c9a4780-bd97-11eb-970e-59b5779c52cc.png)



<br/>

**연결리스트는?**

데이터를 앞 뒤 데이터에 따라 저장

(데이터의 각 성분들이 다음 성분을 기억하고 있는 구조)

![image](https://user-images.githubusercontent.com/78403443/119492159-b50b6180-bd99-11eb-8f21-8ab408d617d8.png)

그림과 같은 구조에서 만약 C를 추가한다고 가정해보자

이때 가장 먼저할 일은 B와 D의 연결을 끊어주는 것이다.

그리고 B가 D를 가리킨 화살표를 C로 향하도록 해준다. 

그리고, C가 D를 향하도록 해주면 리스트에서 C, D로의 인덱스 조정이 필요없이 끊고 두번의 연결을 이어주는 것만으로도 리스트의 추가가 완료된다.

![image](https://user-images.githubusercontent.com/78403443/119492445-0e739080-bd9a-11eb-997b-242b7dad56c2.png)

반대로 삭제작업은 B에서 C로 연결되어있는 연결선을 한 칸 건너 뛰어 D로 옮겨주면 그것으로 삭제작업은 종료이다.

왜냐하면, 연결리스트는 앞에서 뒤로만 가는 한쪽 방향이기 때문에 A에서 시작하여 C로 갈 수 있는 길이 없기 때문에 자연스럽게 C가 삭제되는 것이다.

![image](https://user-images.githubusercontent.com/78403443/119492682-51cdff00-bd9a-11eb-80da-7843163c28c9.png)

<br/>

그럼 연결리스트를 어떻게 구현할 수 있을지 알아보자!



- **연결리스트 구현**

  - 연결리스트는 크게 두 가지 성분으로 구성되어있다. 

  - 첫번째, 각각의 데이터를 담을 Node라고 하는 성분이다. 

    - 그리고, 하나의 노드는 data를 담는 data파트와 다음을 가리키는 next파트 두개로 구성되어있다.

    ![image](https://user-images.githubusercontent.com/78403443/119493044-b8531d00-bd9a-11eb-97d5-12d1f7f6b116.png)

    - 그리고, 여러개의 노드들이 모여서 구성하는 것이 하나의 연결리스트이다!

    ![image](https://user-images.githubusercontent.com/78403443/119493106-cd2fb080-bd9a-11eb-8afc-f0924f2ce2d8.png)

여러 노드 중에서 가장 앞에 위치한 노드를 Head라고 부른다.

<br/>

그리고, 알고리즘 목적에 맞춰서 원하는 성분을 생성할 수도 있다. 

여기서는 한번, count라고 하는 하나의 연결리스트 안에 존재하는 노드의 수를 담고 있는 변수를 한번 만들어보도록 하겠다. 

![image](https://user-images.githubusercontent.com/78403443/119493405-1da70e00-bd9b-11eb-99c7-cf91ceb5d54d.png)

그럼 노드부터 어떻게 구현할 수 있을지 알아보도록 한다.

<br/>

**노드**

노드의 생긴 모양을 보면 다음과 같이 생겼다. (아래 그림)

![image](https://user-images.githubusercontent.com/78403443/119493733-78d90080-bd9b-11eb-9557-26dc147dee72.png)

먼저 노드라는 객체를 생성한다.

우리가 리스트에 어떤 값을 추가하기 위해서 데이터를 바로 넣는 것이 아닌 우리가 원하는 데이터를 보유한 노드를 추가하는 것이다.

따라서, 원하는 데이터를 보유한 노드를 생성할 수 있다.

그리고, 헤드의 다음 노드는 존재하지 않도록 생성한다.

이것으로서 노드의 구성은 끝났다.

<br/>

이제 연결리스트를 구성해보도록 하겠다.

<br/>

**연결리스트**

연결리스트라는 객체를 생성할 때는 보유한 데이터가 없을 것이므로 다음과 같이 생겼을 것이다. (아래 그림)

![image](https://user-images.githubusercontent.com/78403443/119494055-d8cfa700-bd9b-11eb-9ada-a4bb04c078c1.png)

연결리스트 객체를 생성하도록 하겠다. 

보유한 노드 즉, 데이터가 없으므로 현재 헤드는 아무것도 있지 않다.

그리고, 노드가 없다는 것은 연결리스트에 count개수는 0의 값을 유지하고 있을 것이다.

앞에서 말했다시피 변수의 선택은 알고리즘의 목적에 맞게 변수를 선택해주면 된다.

<br/>

그럼, 연결리스트는 어떤 함수들을 갖고 활용될 수 있는지 알아보도록 하자.

<br/>

먼저 연결리스트에 데이터를 추가하는 방법이다.

연결리스트에 데이터를 추가하는 방법은 두 가지가 있다. 

첫번째, 연결리스트 맨 앞에 데이터를 추가하는 것

두번째, 연결리스트 중간에 데이터를 추가하는 것이다.

<br/>

**먼저, 연결리스트 맨 앞에 즉, 새롭게 헤드를 추가하는 방법에 대해서 알아보자**

![image](https://user-images.githubusercontent.com/78403443/119494605-74f9ae00-bd9c-11eb-83b1-43f937d556e8.png)

맨 앞에 데이터를 추가하는 함수이다.

만약 헤드가 없다면 이 말인 즉슨 현재 연결리스트에 아무런 데이터가 없다는 뜻이다.

이 경우, 연결리스트 앞에 노드가 위치하게 된다.

그리고, 연결리스트의 헤드가 새로 생성된 노드를 갖게 되는 것이다.

그러면 아무것도 없었던 연결리스트는 노드 하나를 갖게 되므로 count개수는 0이었던 값이 1이 될 것이다.

<br/>

![image](https://user-images.githubusercontent.com/78403443/119494963-d7eb4500-bd9c-11eb-8e95-c6dfe57dab55.png)

만약 연결리스트가 비어있지 않다면 어떨까?

지금처럼 현재 어떤 head를 보유하고 있을 것이다. 

그때 새로운 A를 가진 노드가 앞에 위치해야 하는 것이다. 

먼저, count를 하나 늘려주도록 한다. 

그리고, 현재 연결리스트의 헤드를 currentHead로 기록해두도록 한다.

그리고, 새로 들어온 노드를 head로 기록하도록 한다.

마지막으로, 새롭게 기록된 헤드의 다음 노드로 이전 헤드였던 B를 가리키도록 한다.

<br/>

이것으로서 연결리스트 맨 앞에 데이터를 추가하는 함수를 구성해보았다.

<br/>

**다음은 연결리스트 가장 마지막인 데이터를 추가하는 함수를 보도록 한다.**

![image](https://user-images.githubusercontent.com/78403443/119495382-534cf680-bd9d-11eb-9b30-c2ec5fe1dbf5.png)

먼저 append라는 함수명으로 만들도록 한다.

만약, 연결리스트에 데이터가 없다면 위 그림과 같은 구조를 가질 것이다.

그리하여 뒤로 추가되는 데이터 자체가 연결리스트의 새로운 헤드가 될 것이다. 

새로운 노드가 헤드가 될 것이며, 노드의 개수는 1이 될 것이다. 

<br/>

만약 연결리스트에 이미 데이터가 존재한다면 어떨까?

head를 now변수에 담아 둔 다음에 반복문을 통해서 노드의 다음 부분이 아무것도 없을 때까지

즉, 연결리스트의 끝에 도달하도록 한다.

그리고, 다음이 아무것도 없는 노드에게 새로 들어온 노드를 다음 값으로 연결해주면 되겠다.

마지막으로, count를 1 증가시킨다.

![image](https://user-images.githubusercontent.com/78403443/119495672-9a3aec00-bd9d-11eb-89a5-82b5b1d8c394.png)

이것으로서, 연결리스트 가장 마지막에 데이터를 추가하는 작업을 완료하였다.

<br/>

**다음은 특정 위치에 데이터를 추가하는 작업을 진행해보겠다.**

![image](https://user-images.githubusercontent.com/78403443/119496431-7330ea00-bd9e-11eb-8499-8fb56e064d51.png)

먼저, 함수명을 작성해주고 입력되는 파라미터 값으로는 데이터를 보유한 노드와 몇번째 위치에 넣을 것인지 그 숫자를 받아오도록 한다.

만약 삽입할 데이터의 위치가 0보다 작거나 혹은 보유한 노드개수보다 크다면 -1을 리턴함으로써 작업을 종료하겠다.

만약 인덱스 값과 보유한 노드의 개수가 같다면 즉, 연결리스트의 마지막에 데이터를 추가하는 작업이므로 앞서서 작성한 append함수를 활용해서 삽입하도록 하겠다.

만약, 인덱스 값이 0이라면 즉, 연결리스트의 가장 앞에 입력하겠다고 하면 앞에서 작성했던 appendHead함수를 통해서 연결리스트 앞에 데이터를 삽입하도록 한다.

<br/>

만약에 위(사진에 작성된) 두 가지 모두가 아니라고 한다면

![image](https://user-images.githubusercontent.com/78403443/119497377-74aee200-bd9f-11eb-819c-f3a101085779.png)

현재의 head를 담아두도록 하겠다.

그리고, 현재의 위치가 우리가 데이터를 담기 원하는 인덱스 위치까지 반복문을 통하여 움직이도록 한다.

그리고, count 개수를 하나 증가시켜준 뒤 현재 위치의 다음 값을 next라는 변수에 담아두도록 하겠다.

현재 위치의 다음 노드로 들어오는 노드를 지정해주도록 한다. 

마지막으로, 새로 들어온 노드의 다음 노드를 앞에서 저장해둔 next변수를 담도록 하겠다.

<br/>

이렇게 됨으로써, 우리는 연결리스트 원하는 위치에 데이터를 삽입할 수 있다.

<br/>

이번에는 데이터 삭제를 한번 알아보도록 한다.

<br/>

**데이터 삭제**

![image](https://user-images.githubusercontent.com/78403443/119497725-db340000-bd9f-11eb-8ddf-f8d76013e4e2.png)

먼저 함수명을 작성해주고, 현재 헤드의 데이터가 우리가 지우길 원하는 데이터라고 한다면

위와 같은 그림에서 현재 헤드를 옮겨서 헤드의 다음 노드를 head로 지정해주도록 한다. (아래)

![image](https://user-images.githubusercontent.com/78403443/119497837-f9016500-bd9f-11eb-968c-0d432372212c.png)

그렇다면 위와 같이 자연스럽게 처음의 헤드는 사라지게 될 것이며, 노드가 하나 줄었으므로 count개수를 1 감소시켜주도록 한다. (아래 이미지)

![image](https://user-images.githubusercontent.com/78403443/119498033-29e19a00-bda0-11eb-9ef1-35f1bd7a5bb3.png)

<br/>

만약 원하는 데이터가 head에 위치해있지 않다면

우리는 head에서부터 원하는 데이터가 나올 때까지 찾아 내려가야한다.

![image](https://user-images.githubusercontent.com/78403443/119498940-27337480-bda1-11eb-8df1-f0cc0ed29837.png)

현재 헤드를 first라는 변수에 담아두도록 한다.

그리고, first의 다음 노드를 second에 담아두도록 한다.

그리고, 우리가 원하는 데이터가 나올 때까지 반복문으로 끝까지 탐색을 진행한다.

만약 second의 데이터가 우리가 원하는 데이터 값이라고 한다면 first의 다음 노드를 second의 다음 노드로 지정해주도록 한다.

그러면, 위 그림과 같은 구조를 갖는 연결리스트가 생성되며 자동으로 B는 사라지게 될 것이다.

그리고, count의 개수를 하나 줄여주고 반복문을 탈출해주도록 하겠다.

만약, 조건문에 걸려서 데이터가 삭제가 되지 않는다면 second노드가 first로 

second의 다음 노드가 second로 바뀌면서 다시 삭제할 데이터인지 검사를 진행하게 되겠다.

<br/>

이렇게 우리는 연결리스트의 데이터 삭제에 대해 알아보았다.

<br/>

**마지막으로, 연결리스트의 데이터가 몇개가 있는지 알아보기 위한 getCount 함수를 작성해보았다.**

![image](https://user-images.githubusercontent.com/78403443/119499103-5518b900-bda1-11eb-9e16-b5df92006eb0.png)

하지만, 보이는 것과 같이 바로 self.count를 활용하여 쉽게 개수를 얻을 수 있다.

<br/>

지금까지 연결리스트에 대해 살펴보았다.

<br/>

이번엔 연결리스트의 확장된 개념, 트라이구조에 대해 살펴본다.

---

**트라이구조**

- **트라이(Trie)구조란?**

![image](https://user-images.githubusercontent.com/78403443/119499632-dd975980-bda1-11eb-9a44-8a64f7327178.png)

트라이구조 :: 문자열을 효율적으로 저장하고 탐색하기 위한 트리형태의 자료구조

위 그림에서 보는 것 처럼 D로 시작하는 문자는 DOG, DOT, DID를 그림처럼 저장할 수 있는 구조이다.

<br/>

그럼 트라이구조의 구조를 조금 더 자세히 알아보도록 하겠다.

<br/>

- **트라이(Trie)구조 구현**

![image](https://user-images.githubusercontent.com/78403443/119500100-644c3680-bda2-11eb-8fd0-8d609ae3f9b7.png)

먼저 연결리스트처럼 노드가 존재한다.

각 노드는 데이터 부분과 아래 하위 자식들의 노드를 가지고 있다. 

다시, 자식 노드들 안에는 노드들이 포함되있다.

또한, 각 노드는 다시 자식 노드를 갖게되고, 위 그림과 같은 구조를 가질 수 있게 되는 것이다.

<br/>

**트라이구조의 전체적인 구조이다. (아래)**

![image](https://user-images.githubusercontent.com/78403443/119500529-df155180-bda2-11eb-8e2f-b6ad6f4f31d6.png)

문자열은 D로만 시작하는 것이 아닌 A, B, C, D 우리가 원하는 문자열로 시작할 수 있다.

따라서, 한 개의 트라이구조의 가장 최상위 부분은 Null값 혹은 None을 갖고, 그 아래에서부터 우리가 원하는 문자열을 시작할 수 있어야 한다.

이때, None값을 갖는 최상위 부모를 우리는 HEAD라고 부른다.

<br/>

그럼 어떻게해야 트라이구조를 구현할 수 있을지 같이 한번 살펴보자

<br/>

**노드**

![image](https://user-images.githubusercontent.com/78403443/119501022-682c8880-bda3-11eb-8cda-c7a907f7239e.png)

노드클래스를 구현해보도록 하겠다.

(그럼 다음과 같이 생겼다. (위 그림... 노드표시))

생성자를 생성하고, 데이터를 넣어주도록 하겠다.

그리고, 자식 노드들을 갖게 될 리스트 혹은 해시를 생성해주도록 하겠다.

이렇게 우리는 노드의 구현이 끝났다.

<br/>

다음은 트라이구조이다.

<br/>

**트라이구조**

![image](https://user-images.githubusercontent.com/78403443/119501257-aaee6080-bda3-11eb-83f5-2e5428fe7238.png)

먼저, 트라이 객체를 생성하도록 한다.

그리고, 생성자를 생성한다. 

트라이구조의 최상위부분은 None값을 갖는 Node(노드)를 삽입하도록 한다.

이렇게 트라이구조의 틀이 완성되었다.

<br/>

그럼 트라이구조에 데이터를 어떻게 삽입할 수 있을지 보자.

![image](https://user-images.githubusercontent.com/78403443/119503036-81363900-bda5-11eb-9d92-38781e954d4a.png)

insert 함수명으로 짓도록 하겠다.

그리고, 트라이구조의 가장 최상위부모를 불러온다.

트라이구조에 넣길 원하는 문자열을 반복문으로 한글자씩 읽도록 한다.

<br/>

![image](https://user-images.githubusercontent.com/78403443/119502465-ec334000-bda4-11eb-8adf-83a5a4316ae5.png)

현재 최상위부모의 자식 노드를 불러오고 자식 노드안에 우리가 넣길 원하는 첫번째 문자가 있는지 없는지 검사를 한다. (위 이미지)

![image](https://user-images.githubusercontent.com/78403443/119502581-0a00a500-bda5-11eb-922a-540867faba5b.png)



만약 원하는 글자가 없다면 현재 자식에 새로운 노드를 추가해주도록 한다.

그리고, 추가된 자식을 다시 HEAD로 지정해서 다음 문자열에 대한 작업을 반복할 수 있도록 만들어준다.

<br/>

![image](https://user-images.githubusercontent.com/78403443/119502670-2270bf80-bda5-11eb-8138-649379a9d301.png)

만약 자식 노드들 중에 다음 문자열이 있다면 새로운 노드를 추가할 것 없이 바로 다음 문자열의 노드를 새로운 부모로 지정하여 계속해서 추가 작업을 진행할 수 있도록 하면 되겠다.

<br/>

---

연결리스트와 트라이구조는 알고리즘의 목적에 맞춰서 다양한 함수들을 가질 수 있다. 

오늘 강의로는 여러 함수들을 모두 다룰 수 없기 때문에 정말 간단하게 트라이구조와 연결리스트를 생성하는 것만을 살펴보았다.

<br/>

스스로 직접 변수를 선택하고, 원하는 함수를 구현할 수 있도록 연습해야한다.

<br/>

그럼 트라이구조는 어디에 사용될 수 있는지 간단한 활용예시를 보자!

<br/>

**트라이구조 활용**

![image](https://user-images.githubusercontent.com/78403443/119502318-c7d76380-bda4-11eb-8ecb-9220278d1cc9.png)

가장 대표적으로 추천검색어가 있다.

한 글자 한 글자를 입력할 때마다 각각의 단어들이 이전 사용자들이 몇번을 검색했었는지 그 검색횟수들을 갖고있다.

그에 맞추어 가장 많이 사용되었던 다음 문자열을 추천해주는 방식으로 트라이구조가 활용될 수 있다.
